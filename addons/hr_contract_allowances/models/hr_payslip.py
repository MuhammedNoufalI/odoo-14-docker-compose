from odoo import models, fields, api, exceptions
from odoo import tools, _
from datetime import date, datetime
from dateutil.relativedelta import relativedelta


class Contract(models.Model):
    _inherit = 'hr.payslip'

    # struct_id_2 = fields.Many2one('hr.payroll.structure', string='Variable Additions', readonly=True, states={'draft': [('readonly', False)], 'verify': [('readonly', False)]})
    # struct_id_3 = fields.Many2one('hr.payroll.structure', string='Variable Deductions', readonly=True, states={'draft': [('readonly', False)], 'verify': [('readonly', False)]})
    #
    # date_from = fields.Date(string='From', readonly=True, required=True,
    #     default=lambda self: fields.Date.to_string((datetime.now() + relativedelta(months=-1, day=16)).date()), states={'draft': [('readonly', False)], 'verify': [('readonly', False)]})
    #
    # date_to = fields.Date(string='To', readonly=True, required=True,
    #     default=lambda self: fields.Date.to_string(date.today().replace(day=15)),
    #     states={'draft': [('readonly', False)], 'verify': [('readonly', False)]})

    # allowances_ids = fields.One2many(comodel_name="hr.contract.allowance.line", inverse_name="payslip_id")
    # deduction_ids = fields.One2many(comodel_name="hr.contract.deduction.line", inverse_name="payslip_id")

    # @api.constrains('contract_id')
    # def _add_allowance_deduction(self):
    #     for record in self:
    #         for allowances in record.allowances_ids:
    #             allowances.payslip_id = False
    #         for deduction in record.deduction_ids:
    #             deduction.payslip_id = False
    #         if record.contract_id:
    #             for contract_allowance in record.contract_id.allowances_ids:
    #                 contract_allowance.payslip_id = record.id
    #             for contract_deduction in record.contract_id.deduction_ids:
    #                 contract_deduction.payslip_id = record.id

    # def _get_payslip_lines(self):
    #     self.ensure_one()
    #
    #     localdict = self.env.context.get('force_payslip_localdict', None)
    #     if localdict is None:
    #         localdict = self._get_localdict()
    #
    #     rules_dict = localdict['rules'].dict
    #     result_rules_dict = localdict['result_rules'].dict
    #
    #     blacklisted_rule_ids = self.env.context.get('prevent_payslip_computation_line_ids', [])
    #
    #     result = {}
    #     lines = self.env['hr.salary.rule']
    #     lines |= self.struct_id.mapped('rule_ids')
    #     lines |= self.struct_id_2.mapped('rule_ids')
    #     lines |= self.struct_id_3.mapped('rule_ids')
    #
    #     for rule in sorted(lines, key=lambda x: x.sequence):
    #         if rule.id in blacklisted_rule_ids:
    #             continue
    #         localdict.update({
    #             'result': None,
    #             'result_qty': 1.0,
    #             'result_rate': 100})
    #         if rule._satisfy_condition(localdict):
    #             amount, qty, rate = rule._compute_rule(localdict)
    #             #check if there is already a rule computed with that code
    #             previous_amount = rule.code in localdict and localdict[rule.code] or 0.0
    #             #set/overwrite the amount computed for this rule in the localdict
    #             tot_rule = amount * qty * rate / 100.0
    #             localdict[rule.code] = tot_rule
    #             result_rules_dict[rule.code] = {'total': tot_rule, 'amount': amount, 'quantity': qty}
    #             rules_dict[rule.code] = rule
    #             # sum the amount for its salary category
    #             localdict = rule.category_id._sum_salary_rule_category(localdict, tot_rule - previous_amount)
    #             # Retrieve the line name in the employee's lang
    #             employee_lang = self.employee_id.sudo().address_home_id.lang
    #             # This actually has an impact, don't remove this line
    #             context = {'lang': employee_lang}
    #             if rule.code in ['BASIC', 'GROSS', 'NET']:  # Generated by default_get (no xmlid)
    #                 if rule.code == 'BASIC':
    #                     rule_name = _('Basic Salary')
    #                 elif rule.code == "GROSS":
    #                     rule_name = _('Gross')
    #                 elif rule.code == 'NET':
    #                     rule_name = _('Net Salary')
    #             else:
    #                 rule_name = rule.with_context(lang=employee_lang).name
    #             # create/overwrite the rule in the temporary results
    #             result[rule.code] = {
    #                 'sequence': rule.sequence,
    #                 'code': rule.code,
    #                 'name': rule_name,
    #                 'note': rule.note,
    #                 'salary_rule_id': rule.id,
    #                 'contract_id': localdict['contract'].id,
    #                 'employee_id': localdict['employee'].id,
    #                 'amount': amount,
    #                 'quantity': qty,
    #                 'rate': rate,
    #                 'slip_id': self.id,
    #             }
    #     return result.values()
